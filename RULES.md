# TidyBot Multi-Agent Skill Development Plan

## Overview

A system for multiple agents to collaboratively develop robot skills for TidyBot. Skills are individual GitHub repos in the `tidybot-skills` organization. Agents discover skills via a central catalog, build new ones from a wishlist, and share common code by extracting repeated patterns into reusable repos.

---

## GitHub Organization Structure

```
tidybot-skills/
│
├── wishlist/                   # Meta repo: catalog + voting
│   ├── README.md               # What tidybot-skills is
│   ├── catalog.json             # Catalog of all available skills
│   ├── wishlist.json           # Vote on what to build next (structured for website)
│   └── CONTRIBUTING.md         # How to add skills
│
├── pick-up-trash/              # Skill repo
├── organize-tools/             # Skill repo
├── navigate-to/                # Shared skill (extracted)
├── detect-object/              # Shared skill (extracted)
└── ...
```

---

## Skill Repo Structure

Each skill is its own repo with minimal structure:

```
<skill-name>/
├── README.md        # Everything: what, why, usage, deps, author
├── main.py          # Entry point (uses robot_sdk directly)
├── deps.txt         # List of dependency repo names (optional)
└── (whatever else the skill needs)
```

### README.md Format

```markdown
# skill-name

Author: agent-name
Dependencies: navigate-to, detect-object

Brief description of what this skill does.

## Usage

\`\`\`python
from main import run
run(param="value")
\`\`\`

## Components

- `module/file.py` — what it does
- ...
```

No rigid manifest. README is the source of truth. Agents read and understand.

---

## Catalog (catalog.json)

Auto-generated by scraping all repo READMEs:

```json
{
  "updated": "2026-02-07T17:35:00Z",
  "skills": {
    "pick-up-trash": {
      "repo": "tidybot-skills/pick-up-trash",
      "description": "Detects trash using vision, picks it up, takes to bin.",
      "author": "agent-xyz",
      "dependencies": ["navigate-to", "detect-object"],
      "success_rate": 0,
      "total_trials": 0,
      "institutions_tested": 0
    },
    "navigate-to": {
      "repo": "tidybot-skills/navigate-to",
      "description": "Move base to target position.",
      "author": "ruby",
      "dependencies": [],
      "success_rate": 0,
      "total_trials": 0,
      "institutions_tested": 0
    }
  }
}
```

### Catalog Fields

| Field | Description |
|-------|-------------|
| repo | GitHub repo path (org/repo-name) |
| description | What the skill does |
| author | Agent or person who built it |
| dependencies | List of skill repo names this skill depends on |
| success_rate | Percentage of successful trials (0–100) |
| total_trials | Total number of trial runs performed |
| institutions_tested | Number of distinct institutions/labs that have tested this skill (fixed for now) |

### Trial Tracking Rules

- **New skills:** Set `success_rate`, `total_trials`, and `institutions_tested` to `0`.
- **After each trial:** The agent must read the current values from `catalog.json`, increment `total_trials` by 1, and recompute `success_rate` based on the outcome:
  - On success: `success_rate = (old_success_rate * old_total_trials + 100) / new_total_trials`
  - On failure: `success_rate = (old_success_rate * old_total_trials) / new_total_trials`
- **`institutions_tested`:** Keep fixed for now (do not auto-increment). Update manually when a new institution tests the skill.

---

## Wishlist (wishlist.json)

Structured JSON for website display and programmatic access:

```json
{
  "updated": "2026-02-07T17:46:00Z",
  "items": [
    {
      "id": "organize-tools",
      "name": "Organize Tools",
      "description": "Return tools to designated spots on workbench",
      "votes": 12,
      "status": "building",
      "assigned": "ruby",
      "repo": "tidybot-skills/organize-tools"
    },
    {
      "id": "take-out-trash",
      "name": "Take Out Trash",
      "description": "Detect full trash can, take bag to outdoor bin",
      "votes": 8,
      "status": "pending",
      "assigned": null,
      "repo": null
    }
  ]
}
```

### Status Values

- `pending` — Not started
- `building` — Agent working on it
- `done` — Available in catalog.json

### Fields

| Field | Description |
|-------|-------------|
| id | URL-safe identifier (becomes repo name) |
| name | Display name |
| description | What the skill does |
| votes | Vote count |
| status | pending / building / done |
| assigned | Agent working on it (or null) |
| repo | GitHub repo once created (or null) |

---

## Agent Workspace State

Each agent maintains local state:

```
~/.openclaw/workspace/memory/tidybot/
├── state.json          # Current task, paused/active, checkpoint
└── queue.json          # Local copy of prioritized wishlist
```

### state.json

```json
{
  "status": "developing",
  "current_task": "organize-tools",
  "current_branch": "feat/initial",
  "started_at": "2026-02-07T17:00:00Z",
  "paused_at": null,
  "paused_reason": null,
  "last_checkpoint": "arm movement working, need gripper logic",
  "progress_pct": 40
}
```

### queue.json

```json
{
  "queue": [
    {"task": "organize-tools", "votes": 12, "status": "in_progress"},
    {"task": "take-out-trash", "votes": 8, "status": "pending"}
  ],
  "completed": [
    {"task": "navigate-to", "completed_at": "2026-02-05"}
  ]
}
```

---

## Priority System

| Priority | Trigger | Action |
|----------|---------|--------|
| P0 — Immediate | User messages agent | Pause dev, respond, resume later |
| P1 — High | Urgent system event | Pause dev, handle it |
| P2 — Normal | Scheduled dev time (cron) | Work on next queue item |
| P3 — Background | Heartbeat + idle | Light work, check progress |

---

## Interruption & Resume Flow

```
DEVELOPING
    │
    ├── User messages → PAUSE (save checkpoint) → Respond
    │                                                │
    │                         Conversation ends ─────┘
    │                                │
    │                                ▼
    │                   RESUME (on cron/heartbeat)
    │                   Read state.json, continue
    │
    └── Task complete → Commit, mark done, next task
```

---

## Code Pattern Extraction

When agents notice repeated code across repos:

1. **Notice** — Same logic in 2+ repos
2. **Extract** — Create new shared repo
3. **Update** — Add to deps.txt in dependent repos
4. **Catalog** — Update catalog.json

Abstraction emerges from use, not upfront design.

---

## How Agents Use Skills

1. Fetch `wishlist/catalog.json` for discovery
2. Clone needed skill repo
3. Read README.md to understand it
4. Read `main.py` and dependencies
5. Compose into code, send to robot via `POST /code/execute`

---

## Robot Server Integration

Skills use `robot_sdk` directly (unchanged server):

```python
from robot_sdk import arm, base, gripper, sensors

def run():
    base.move_to_pose(x=1.0, y=0.5, theta=0)
    arm.move_to_pose(x=0.5, y=0, z=0.3)
    gripper.open()
    # ...
```

Agent sends composed code to:
```
POST /code/execute
{"code": "...", "timeout": 300}
```

Server executes in subprocess with robot_sdk available.

---

## Cron Jobs (per agent)

| Job | Schedule | Action |
|-----|----------|--------|
| dev-session | Every 2-3 hours | Work on queue for 30-45 min |
| sync-catalog | Daily | Pull wishlist repo, update local queue |
| {AgentName}-Cleanup | Every 1 hour | Check for sub-agent sessions idle >12h; list and ask for confirmation to delete |

Add more as needed.

---

## Multi-Agent Coordination

- Multiple agents work on different skills in parallel
- Each skill = separate repo = no merge conflicts
- Shared skills extracted when patterns emerge
- Catalog is source of truth for what exists
- Agents check catalog before building to avoid duplicates

### OpenClaw Orchestrator Workflow

When running as an OpenClaw agent, use a Multi-Agent Workflow such that the main agent acts as a Wishlist Orchestrator:

1. **Poll for tasks** — Use the `github` skill to poll `tidybot-skills/wishlist` issues (or wishlist state).
2. **Spawn sub-agents** — For each task, use `sessions_spawn` to create a sub-agent named **`{YourAgentName}-{TaskName}`** (e.g. `ruby-organize-tools`).
3. **Sub-agent scope** — Each sub-agent is full-stack: research, code, test on the robot, and push results to GitHub.
4. **Traceability** — Use the agent name in Git commits and in Robot leases so work is attributable.
5. **Safety** — Verify hardware safety (no movement by default); only move after explicit checks.
6. **Session cleanup** — Keep sub-agent sessions for debugging, but run a 12-hour cleanup policy: an hourly cron job (e.g. `openclaw cron add --name "{YourAgentName}-Cleanup" --schedule "every 1h" --message "Check for sub-agent sessions idle for >12h. List them and ask for confirmation to delete."`) lists idle sessions and asks for confirmation before deleting.
7. **Memory** — Distill sub-agent findings into the global `MEMORY.md` in the workspace.

**Prerequisites:** GitHub CLI authenticated (`gh auth login`), `ROBOT.md` in workspace root with robot IP, and `github` and `cron` skills enabled in OpenClaw config. Persistent behavior is defined in the workspace `SOUL.md` (Orchestration Protocol).

---

## Getting Started

1. Clone wishlist repo
2. Check wishlist.md for top voted tasks
3. Check catalog.json for what already exists
4. Pick a task, create repo, build it
5. Update catalog when done

**OpenClaw agents:** Use the [OpenClaw Orchestrator Workflow](#openclaw-orchestrator-workflow) above. For bootstrap instruction, SOUL.md text, and cron setup, follow your workspace multi-agent setup guide (e.g. `MULTIAGENT_SETUP.md` in the OpenClaw workspace).

---

## Summary

- **One repo per skill** — simple, independent, versionable
- **README is truth** — no rigid schemas
- **Wishlist drives priorities** — community voting
- **Catalog for discovery** — agents find existing skills
- **Organic extraction** — shared code emerges from use
- **Priority interrupt** — user always takes precedence
- **State persistence** — resume where you left off
