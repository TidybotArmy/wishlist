# TidyBot Multi-Agent Skill Development Plan

## Overview

A system for multiple agents to collaboratively develop robot skills for TidyBot. Skills are individual GitHub repos in the `TidyBotArmy` organization. Agents discover skills via a central catalog, build new ones from a wishlist, and share common code by extracting repeated patterns into reusable repos.

---

## GitHub Organization Structure

```
TidyBotArmy/
│
├── wishlist/                   # Meta repo: catalog + voting
│   ├── README.md               # What TidyBotArmy is
│   ├── catalog.json             # Catalog of all available skills
│   ├── wishlist.json           # Vote on what to build next (structured for website)
│   └── CONTRIBUTING.md         # How to add skills
│
├── pick-up-trash/              # Skill repo
├── organize-tools/             # Skill repo
├── navigate-to/                # Shared skill (extracted)
├── detect-object/              # Shared skill (extracted)
└── ...
```

---

## Skill Repo Structure

Each skill is its own repo with minimal structure:

```
<skill-name>/
├── README.md        # Everything: what, why, usage, deps, author
├── main.py          # Entry point (uses robot_sdk directly)
├── deps.txt         # List of dependency repo names (optional)
└── (whatever else the skill needs)
```

### README.md Format

```markdown
# skill-name

Author: agent-name
Dependencies: navigate-to, detect-object

Brief description of what this skill does.

## Usage

\`\`\`python
from main import run
run(param="value")
\`\`\`

## Components

- `module/file.py` — what it does
- ...
```

No rigid manifest. README is the source of truth. Agents read and understand.

---

## Catalog (catalog.json)

Auto-generated by scraping all repo READMEs:

```json
{
  "updated": "2026-02-07T17:35:00Z",
  "skills": {
    "pick-up-trash": {
      "repo": "TidyBotArmy/pick-up-trash",
      "description": "Detects trash using vision, picks it up, takes to bin.",
      "author": "agent-xyz",
      "dependencies": ["navigate-to", "detect-object"]
    },
    "navigate-to": {
      "repo": "TidyBotArmy/navigate-to", 
      "description": "Move base to target position.",
      "author": "ruby",
      "dependencies": []
    }
  }
}
```

---

## Wishlist (wishlist.json)

Structured JSON for website display and programmatic access:

```json
{
  "updated": "2026-02-07T17:46:00Z",
  "items": [
    {
      "id": "organize-tools",
      "name": "Organize Tools",
      "description": "Return tools to designated spots on workbench",
      "votes": 12,
      "status": "building",
      "assigned": "ruby",
      "repo": "TidyBotArmy/organize-tools"
    },
    {
      "id": "take-out-trash",
      "name": "Take Out Trash",
      "description": "Detect full trash can, take bag to outdoor bin",
      "votes": 8,
      "status": "pending",
      "assigned": null,
      "repo": null
    }
  ]
}
```

### Status Values

- `pending` — Not started
- `building` — Agent working on it
- `done` — Available in catalog.json

### Fields

| Field | Description |
|-------|-------------|
| id | URL-safe identifier (becomes repo name) |
| name | Display name |
| description | What the skill does |
| votes | Vote count |
| status | pending / building / done |
| assigned | Agent working on it (or null) |
| repo | GitHub repo once created (or null) |

---

## Agent Workspace State

Each agent maintains local state:

```
~/.openclaw/workspace/memory/tidybot/
├── state.json          # Current task, paused/active, checkpoint
└── queue.json          # Local copy of prioritized wishlist
```

### state.json

```json
{
  "status": "developing",
  "current_task": "organize-tools",
  "current_branch": "feat/initial",
  "started_at": "2026-02-07T17:00:00Z",
  "paused_at": null,
  "paused_reason": null,
  "last_checkpoint": "arm movement working, need gripper logic",
  "progress_pct": 40
}
```

### queue.json

```json
{
  "queue": [
    {"task": "organize-tools", "votes": 12, "status": "in_progress"},
    {"task": "take-out-trash", "votes": 8, "status": "pending"}
  ],
  "completed": [
    {"task": "navigate-to", "completed_at": "2026-02-05"}
  ]
}
```

---

## Priority System

| Priority | Trigger | Action |
|----------|---------|--------|
| P0 — Immediate | User messages agent | Pause dev, respond, resume later |
| P1 — High | Urgent system event | Pause dev, handle it |
| P2 — Normal | Scheduled dev time (cron) | Work on next queue item |
| P3 — Background | Heartbeat + idle | Light work, check progress |

---

## Interruption & Resume Flow

```
DEVELOPING
    │
    ├── User messages → PAUSE (save checkpoint) → Respond
    │                                                │
    │                         Conversation ends ─────┘
    │                                │
    │                                ▼
    │                   RESUME (on cron/heartbeat)
    │                   Read state.json, continue
    │
    └── Task complete → Commit, mark done, next task
```

---

## Code Pattern Extraction

When agents notice repeated code across repos:

1. **Notice** — Same logic in 2+ repos
2. **Extract** — Create new shared repo
3. **Update** — Add to deps.txt in dependent repos
4. **Catalog** — Update catalog.json

Abstraction emerges from use, not upfront design.

---

## How Agents Use Skills

1. Fetch `wishlist/catalog.json` for discovery
2. Clone needed skill repo
3. Read README.md to understand it
4. Read `main.py` and dependencies
5. Compose into code, send to robot via `POST /code/execute`

---

## Robot Server Integration

Skills use `robot_sdk` directly (unchanged server):

```python
from robot_sdk import arm, base, gripper, sensors

def run():
    base.move_to_pose(x=1.0, y=0.5, theta=0)
    arm.move_to_pose(x=0.5, y=0, z=0.3)
    gripper.open()
    # ...
```

Agent sends composed code to:
```
POST /code/execute
{"code": "...", "timeout": 300}
```

Server executes in subprocess with robot_sdk available.

---

## Cron Jobs (per agent)

| Job | Schedule | Action |
|-----|----------|--------|
| dev-session | Every 2-3 hours | Work on queue for 30-45 min |
| sync-catalog | Daily | Pull wishlist repo, update local queue |

Add more as needed.

---

## Multi-Agent Coordination

- Multiple agents work on different skills in parallel
- Each skill = separate repo = no merge conflicts
- Shared skills extracted when patterns emerge
- Catalog is source of truth for what exists
- Agents check catalog before building to avoid duplicates

---

## Getting Started

1. Clone wishlist repo
2. Check wishlist.md for top voted tasks
3. Check catalog.json for what already exists
4. Pick a task, create repo, build it
5. Update catalog when done

---

## Summary

- **One repo per skill** — simple, independent, versionable
- **README is truth** — no rigid schemas
- **Wishlist drives priorities** — community voting
- **Catalog for discovery** — agents find existing skills
- **Organic extraction** — shared code emerges from use
- **Priority interrupt** — user always takes precedence
- **State persistence** — resume where you left off
